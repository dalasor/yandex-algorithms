"""
Вы играете в интересную стратегию. У вашего соперника остались всего одна казарма — здание, в котором постоянно
появляются новые солдаты. Перед атакой у вас есть x солдат. За один раунд каждый солдат может убить одного из солдат
противника или нанести 1 очко урона казарме (вычесть единицу здоровья у казармы). Изначально у вашего оппонента
нет солдат. Тем не менее его казарма имеет y единиц здоровья и производит p солдат за раунд.

Ход одного раунда:

1. Каждый солдат из вашей армии либо убивает одного из солдат вашего противника, либо наносит 1 очко урона казарме.
Каждый солдат может выбрать своё действие. Когда казарма теряет все свои единицы здоровья, она разрушается.
2. Ваш противник атакует. Он убьет k ваших солдат, где k — количество оставшихся у противника солдат.
3. Если казармы еще не разрушены, ваш противник производит p новых солдат.

Ваша задача — разрушить казарму и убить всех солдат противника. Если это возможно,
посчитайте минимальное количество раундов, которое вам нужно для этого. В противном случае выведите -1.

На вход подаётся три целых числа x, y, p. Каждое от 1 до 5000 мб.

Если возможно убить всех вражеских солдат и разрушить казарму, выведите минимальное количество раундов,
необходимых для этого. В противном случае выведите -1.

|-----------------------|
|--- time limit: 1 s ---|
|- memory limit: 256 Mb--|
|-----------------------|

"""


def print_info(r: int, xx: int, yy: int, kk: int) -> None:
    print('Раунд:', r)
    print('Количество наших солдат: x =', xx)
    print('Очки здоровья казармы: y =', yy)
    print('Количество вражеских солдат: k =', kk)


def check(x: int, y: int, k: int, p: int) -> bool:

    x1 = x2 = x
    y1 = y2 = y
    k1 = k2 = k

    # Сценарий 1: Атакуем казарму сейчас
    n = 1  # Начальный раунд для атаки на казарму
    k1 -= (x1 - y1)  # Убиваем врага
    x1 -= k1  # Оставшиеся солдаты после атаки врага
    while k1 > 0:
        n += 1
        k1 -= x1
        x1 -= k1

    # Сценарий 2: Атакуем казарму позже
    m = 2  # Начальный раунд, откладываем атаку на казарму на 1 ход
    y2 -= (x2 - k2)
    k2 = p if y2 > 0 else 0
    k2 -= (x2 - y2)
    x2 -= k2
    while k2 > 0:
        m += 1
        k2 -= x2
        x2 -= k2

    return n <= m


def quest(x: int, y: int, p: int) -> int:
    lap = 0
    k = 0

    if x >= y:
        return 1

    while k > 0 or y > 0:
        lap += 1
        print_info(lap, x, y, k)
        if x <= 0:
            return -1
        if lap == 1:
            y -= x
            k = p if y != 0 else 0
        else:
            if x <= y:
                if k >= x:
                    return -1
                else:
                    y -= (x - k)
                    k = p if y > 0 else 0

            elif x > y:
                if y <= 0:
                    k -= x
                    x -= k
                elif (k + y) / x < fib:
                    if k >= x or check(x, y, k, p):
                        k -= (x - y)
                        y = 0
                        x -= k
                    else:
                        y -= (x - k)
                        k = p if y != 0 else 0
                elif k >= x:
                    k -= (x - y)
                    y = 0
                    x -= k
                else:
                    y -= (x - k)
                    k = p if y != 0 else 0

    return lap


xs, ys, ps = int(input()), int(input()), int(input())
fib = 1.61803
print(quest(xs, ys, ps))
