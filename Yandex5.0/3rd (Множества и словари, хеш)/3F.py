"""
С целью экономии чернил в картридже принтера было принято решение укоротить некоторые слова в тексте.
Для этого был составлен словарь слов, до которых можно сокращать более длинные слова. Слово из текста
можно сократить, если в словаре найдется слово, являющееся началом слова из текста. Например, если в
списке есть слово "лом", то слова из текста "ломбард", "ломоносов" и другие слова, начинающиеся на "лом",
можно сократить до "лом".

Если слово из текста можно сократить до нескольких слов из словаря, то следует сокращать его до самого
короткого слова.

В первой строке через пробел вводятся слова из словаря, слова состоят из маленьких латинских букв.
Гарантируется, что словарь не пуст и количество слов в словаре не превышет 1000, а длина слов — 100 символов.

Во второй строке через пробел вводятся слова текста.

Выведите текст, в котором осуществлены замены.

|-----------------------|
|--- time limit: 1 s ---|
|- memory limit: 64 Mb -|
|-----------------------|

"""


def shorten_words(dict_words, text_words):
    dict_set = set(dict_words)

    def find_shortest_prefix(word):
        for i in range(1, len(word) + 1):
            if word[:i] in dict_set:
                return word[:i]
        return word

    return [find_shortest_prefix(word) for word in text_words]


dct = input().split()
text = input().split()
print(*shorten_words(dct, text))


#  Объяснение, почему этот код хорош.
"""
    1. Использование множества для словаря: Преобразование списка слов словаря в множество (set) значительно ускоряет 
    операцию проверки на наличие слова в словаре. Операции поиска в множестве имеют среднюю временную сложность O(1), 
    что гораздо быстрее, чем линейный поиск в списке.

    2. Поиск самого короткого префикса: Алгоритм начинает с проверки самых коротких подстрок каждого слова из текста, 
    постепенно увеличивая длину проверяемой подстроки. Как только находится совпадение в словаре, дальнейший поиск 
    по этому слову прекращается. Это минимизирует количество необходимых сравнений.

    3. Отсутствие предварительной сортировки или дополнительных фильтраций: В отличие от предыдущих попыток, 
    в этом подходе нет необходимости сортировать слова словаря или фильтровать их перед проверкой каждого слова текста. 
    Эти операции могут быть довольно затратными с точки зрения времени, особенно при работе с большими наборами данных.

    4. Прямая обработка каждого слова текста: Подход непосредственно обрабатывает каждое слово текста, исключая 
    необходимость в сложных структурах данных или дополнительных проверках, что упрощает и ускоряет выполнение.
    
    Благодаря этим факторам, алгоритм способен эффективно обрабатывать большие наборы данных, 
    сокращая время выполнения за счет оптимизации поиска и уменьшения количества операций.
"""